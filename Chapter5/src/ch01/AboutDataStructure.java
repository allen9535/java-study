package ch01;

public class AboutDataStructure {

  // 자료 구조(Data Structure)
  // 프로그램에서 사용하는 여러 데이터를 메모리 상에서 관리하는 여러 방법들을 말한다.
  // 효율적인 자료 구조는 좋은 성능을 가진 알고리즘의 기반이 된다.
  // 자료의 효율적인 관리는 프로그램의 수행 속도와 밀접환 연관이 있다.
  // 여러 자료 구조들 중 구현하려는 프로그램에 맞는 최적의 자료 구조를 활용해야 하기 때문에,
  // 자료 구조에 대한 이해는 중요하다.

  // 자료 구조의 종류
  //
  // 선형 자료 구조(한 줄로 자료를 관리하는 구조)
  // 배열(Array): 정해진 크기의 메모리를 할당받은 후 사용한다.
  //              자료의 물리적 위치와 논리적 위치가 동일하다.
  //              데이터를 찾는 속도가 빠르다.
  //              (데이터의 물리적 위치와 논리적 위치가 동일하므로 = 인덱스 연산이 가능하므로)
  //              데이터를 추가하거나 삭제하는 속도는 느리다.
  //              (데이터를 조작할 때마다 여러 과정을 거쳐야 하므로)
  // 연결 리스트(Linked List): 자료(노드)가 추가될 때 마다 메모리를 할당받고, 자료는 링크로 연결한다.
  //                           자료의 물리적 위치와 논리적 위치가 동일하지 않을 수 있다.
  //                           데이터를 찾는 속도는 배열보다 느리다.
  //                           (데이터의 물리적 위치와 논리적 위치가 동일하지 않으므로
  //                            = 인덱스 연산이 불가하므로)
  //                           데이터를 추가하거나 삭제하는 속도는 배열보다 빠르다.
  //                           (링크 연결만 수정하면 되므로)
  // 스택(Stack): 가장 나중에 입력된 자료가 가장 먼저 출력되는 자료 구조.
  //              A, B, C, D의 순서대로 자료가 입력되었을 때 가장 마지막에 입력된 D가 가장 먼저 출력된다.
  //              (Last In First Out, LIFO = 후입선출)
  //              스택에 요소를 추가하는 것을 Push, 요소를 꺼내는 것을 Pop, 가장 마지막에 입력된 요소를 Top이라 한다.
  //              push와 pop은 top에서만 이루어진다.(= 자료 추가 및 꺼내기는 top에서만 이루어진다.)
  //              세로로 쌓여 있는 상자를 연상하면 편하다.
  // 큐(Queue): 가장 먼저 입력된 자료가 가장 먼저 출력되는 자료 구조.
  //            A, B, C, D의 순서대로 자료가 입력되었을 때 가장 먼저 입력된 A가 가장 먼저 출력된다.
  //            (First In First Out, FIFO = 선입선출)
  //            큐에 요소를 추가하는 것을 Enqueue, 요소를 꺼내는 것을 Dequeue, 가장 먼저 입력된 요소를 Front, 가장 마지막에 입력된 요소를 Rear라 한다.
  //            enqueue는 rear에서만, dequeue는 front에서만 이루어진다.
  //            (자료의 추가는 rear에서만, 꺼내기는 front에서만 이루어진다.)
  //            가로로 나란히 있는 상자를 연상하면 편하다.
  //
  // 비 선형 자료 구조
  // 트리: 부모 노드와 자식 노드 간 연결로 이루어진 자료 구조
  // 이진 트리(Binary Tree): 부모 노드에 자식 노드가 두 개 이하인 트리.
  //                         왼쪽 노드를 왼쪽 자식 노드(Left Child Node),
  //                         오른쪽 노드를 오른쪽 자식 노드(Right Child Node)라 한다.
  //                         자식 노드가 두 개 이하이기 때문에 부모 노드만 존재할 수도 있고,
  //                         자식 노드가 한 개일 수도 있다.
  // 포화 이진 트리(Full Binary Tree): 맨 위의 노드(Root) 아래에 두 개의 자식 노드가 있고
  //                                   또 그 아래에 두 개씩 자식 노드가 있고...
  //                                   와 같은 식으로 모든 노드가 채워진 트리를
  //                                   포화 이진 트리(Full Binary Tree)라 한다.
  //                                   (마지막 레벨의 노드가 꽉 차 있을 필요는 없지만, 중간이 비어서는 안됨.)
  // 힙(Heap): 힙은 포화 이진 트리에서 왼쪽 자식 노드부터 채워가며 만들어지는
  //           완전 이진 트리(Complete Binary Tree)이다.
  //           힙의 종류에는 Max Heap과 Min Heap 두 가지가 있다.
  //           Max Heap: 부모 노드는 자식 노드보다 항상 크거나 같은 값을 갖는다.
  //           Min Heap: 부모 노드는 자식 노드보다 항상 작거나 같은 값을 갖는다.
  //           이러한 힙의 특성을 이용해 정렬하는 Heap Sort라는 정렬 방식이 있고,
  //           우선 큐(Priority Queue)에서도 힙을 사용한다.
  // 이진 검색 트리(Binary Search Tree): 검색을 위해 만들어진 트리로,
  //                                     힙과는 달리 자료(key)의 중복을 허용하지 않는다.
  //                                     왼쪽 자식 노드는 부모 노드보다 작아야 하고,
  //                                     오른쪽 자식 노드는 부모 노드보다 커야 한다.
  //                                     이 트리의 요소 갯수는 2ⁿ - 1 이고,
  //                                     (여기서 n은 노드의 깊이(depth)를 말한다.)
  //                                     검색에 소요되는 시간은 log₂(n)이다.
  //                                     (한 번 노드를 거칠 때마다 비교해야 할 요소가 절반으로 줄기 때문.)
  // * key란 중복을 허용하지 않는 값을 말한다.
  // * 검색에 소요되는 시간을 줄이기 위해 트리를 사용하는데, 편향된 트리(예. 1-2-3-4-5)를 구현하게 되면
  //   결국 걸리는 시간은 log₂(n)이 아니라 n이 된다.
  //   따라서 트리를 만들 때 편향되지 않도록 유의한다. (즉 소요 시간 log₂(n)을 보장할 수 있도록 유의한다.)
  // * 트리 또는 트리의 요소를 전체적으로 한 번 순회하는 것을 Traversal라고 하는데,
  //   부모 노드를 중심으로 했을 때, 왼쪽 자식 노드를 먼저 보고 그 다음 부모 노드를, 그 다음
  //   오른쪽 자식 노드를 보게 되는 traversal를 Inorder Traversal이라 한다.
  //   inorder traversal 탐색을 하게 되면 자료가 정렬되어 출력된다.
  //   jdk 클래스에서는 TreeSet, TreeMap에 구현되어 있다.
  // 그래프(Graph): 정점과 간선들의 유한 집합
  // 정점(Vertex): 여러 특성을 가지는 객체로, 노드(Node)라고도 한다.
  // 간선(Edge): 정점들의 연결 관계를 나타내는 것으로, 링크(Link)라고도 한다.
  //             방향성이 있는 경우와 없는 경우가 있다.
  // 그래프 구현 방법: 인접 행렬(Adjacency Matrix), 인접 리스트(Adjacency List)
  // 그래프 탐색 방법: BFS(Bread First Search), DFS(Depth First Search)
  //
  // 해싱(Hashing): 자료를 검색하기 위한 자료 구조
  // 키(Key)에 대한 자료를 검색하는 사전(Dictionary) 개념의 자료 구조이다.
  // 키는 유일하며, 그 키에 해당하는 값(Value)을 쌍으로 저장한다.
  // 해시 함수에 의해 인덱스 연산이 산술적으로 가능하다.
  // 쉽게 말해 계산을 통해 인덱스를 찾을 수 있다는 뜻으로, 검색 속도가 매우 빠르다.
  // 이러한 해싱이 저장되는 메모리 구조를 해시 테이블이라 한다.
  // jdk 클래스에서는 HashMap, Properties에 구현되어 있다.
  // 기본적인 해시 테이블 구조는 2차원 배열의 형태를 가지므로,
  // 버켓이나 슬롯이 과도하게 많을 수 있다는 문제점이 있었다.(버켓을 행, 슬롯을 열이라 생각하면 편하다.)
  // 이 구조를 효율적으로 만들기 위해 체이닝이라는 메모리 구조가 나타나게 되었다.
  // 링크드 리스트 형태를 가지게 만들었으므로 더 효율적이지만, 구현이 더 복잡하기도 하다.

}